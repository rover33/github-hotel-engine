{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar react_1 = require(\"react\");\n\nvar useInfiniteScroll = function (allItems, observerOptions) {\n  var _a = react_1.useState([]),\n      stateItems = _a[0],\n      setStateItems = _a[1];\n\n  var _b = react_1.useState(null),\n      element = _b[0],\n      setElement = _b[1];\n\n  var itemsRef = react_1.useRef(allItems);\n  var setRef = react_1.useCallback(function (node) {\n    if (node) {\n      setElement(node);\n    }\n  }, []);\n\n  var listener = function (entries) {\n    var first = entries[0];\n\n    if (first.isIntersecting) {\n      setStateItems(function (prevItems) {\n        var prevLength = prevItems.length;\n        var nextItems = itemsRef.current.slice(0, prevLength + 20);\n        return nextItems.length !== prevLength ? nextItems : prevItems;\n      });\n    }\n  };\n\n  var observer = react_1.useRef(new IntersectionObserver(listener, observerOptions));\n  react_1.useEffect(function () {\n    itemsRef.current = allItems;\n    setStateItems(allItems.slice(0, 20));\n  }, [allItems, element]);\n  react_1.useEffect(function () {\n    var currentElement = element;\n    var currentObserver = observer.current;\n\n    if (currentElement) {\n      currentObserver.observe(currentElement);\n    }\n\n    return function () {\n      if (currentElement) {\n        currentObserver.unobserve(currentElement);\n      }\n    };\n  }, [element]);\n  var nextItems = element ? stateItems : [];\n  return [nextItems, setRef];\n};\n\nexports.default = useInfiniteScroll;","map":{"version":3,"sources":["../src/useInfiniteScroll.tsx"],"names":[],"mappings":";;;;;;AAAA,IAAA,OAAA,GAAA,OAAA,CAAA,OAAA,CAAA;;AAYA,IAAM,iBAAiB,GAAG,UACxB,QADwB,EAExB,eAFwB,EAEkB;AAEpC,MAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,EAAA,CAAA;AAAA,MAAC,UAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAa,aAAA,GAAA,EAAA,CAAA,CAAA,CAAb;;AACA,MAAA,EAAA,GAAA,OAAA,CAAA,QAAA,CAAA,IAAA,CAAA;AAAA,MAAC,OAAA,GAAA,EAAA,CAAA,CAAA,CAAD;AAAA,MAAU,UAAA,GAAA,EAAA,CAAA,CAAA,CAAV;;AAEN,MAAM,QAAQ,GAAG,OAAA,CAAA,MAAA,CAAO,QAAP,CAAjB;AAEA,MAAM,MAAM,GAAe,OAAA,CAAA,WAAA,CAAY,UAAA,IAAA,EAAI;AACzC,QAAI,IAAJ,EAAU;AACR,MAAA,UAAU,CAAC,IAAD,CAAV;AACD;AACF,GAJ0B,EAIxB,EAJwB,CAA3B;;AAMA,MAAM,QAAQ,GAAG,UAAC,OAAD,EAAa;AACrB,QAAA,KAAA,GAAA,OAAA,CAAA,CAAA,CAAA;;AAEP,QAAI,KAAK,CAAC,cAAV,EAA0B;AACxB,MAAA,aAAa,CAAC,UAAA,SAAA,EAAS;AACrB,YAAM,UAAU,GAAG,SAAS,CAAC,MAA7B;AACA,YAAM,SAAS,GAAG,QAAQ,CAAC,OAAT,CAAiB,KAAjB,CAAuB,CAAvB,EAA0B,UAAU,GAAG,EAAvC,CAAlB;AAEA,eAAO,SAAS,CAAC,MAAV,KAAqB,UAArB,GAAkC,SAAlC,GAA8C,SAArD;AACD,OALY,CAAb;AAMD;AACF,GAXD;;AAaA,MAAM,QAAQ,GAAG,OAAA,CAAA,MAAA,CAAO,IAAI,oBAAJ,CAAyB,QAAzB,EAAmC,eAAnC,CAAP,CAAjB;AAEA,EAAA,OAAA,CAAA,SAAA,CAAU,YAAA;AACR,IAAA,QAAQ,CAAC,OAAT,GAAmB,QAAnB;AACA,IAAA,aAAa,CAAC,QAAQ,CAAC,KAAT,CAAe,CAAf,EAAkB,EAAlB,CAAD,CAAb;AACD,GAHD,EAGG,CAAC,QAAD,EAAW,OAAX,CAHH;AAKA,EAAA,OAAA,CAAA,SAAA,CAAU,YAAA;AACR,QAAM,cAAc,GAAG,OAAvB;AACA,QAAM,eAAe,GAAG,QAAQ,CAAC,OAAjC;;AACA,QAAI,cAAJ,EAAoB;AAClB,MAAA,eAAe,CAAC,OAAhB,CAAwB,cAAxB;AACD;;AACD,WAAO,YAAA;AACL,UAAI,cAAJ,EAAoB;AAClB,QAAA,eAAe,CAAC,SAAhB,CAA0B,cAA1B;AACD;AACF,KAJD;AAKD,GAXD,EAWG,CAAC,OAAD,CAXH;AAaA,MAAM,SAAS,GAAG,OAAO,GAAG,UAAH,GAAgB,EAAzC;AACA,SAAO,CAAC,SAAD,EAAY,MAAZ,CAAP;AACD,CAlDD;;AAoDA,OAAA,CAAA,OAAA,GAAe,iBAAf","sourceRoot":"","sourcesContent":["\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar react_1 = require(\"react\");\nvar useInfiniteScroll = function (allItems, observerOptions) {\n    var _a = react_1.useState([]), stateItems = _a[0], setStateItems = _a[1];\n    var _b = react_1.useState(null), element = _b[0], setElement = _b[1];\n    var itemsRef = react_1.useRef(allItems);\n    var setRef = react_1.useCallback(function (node) {\n        if (node) {\n            setElement(node);\n        }\n    }, []);\n    var listener = function (entries) {\n        var first = entries[0];\n        if (first.isIntersecting) {\n            setStateItems(function (prevItems) {\n                var prevLength = prevItems.length;\n                var nextItems = itemsRef.current.slice(0, prevLength + 20);\n                return nextItems.length !== prevLength ? nextItems : prevItems;\n            });\n        }\n    };\n    var observer = react_1.useRef(new IntersectionObserver(listener, observerOptions));\n    react_1.useEffect(function () {\n        itemsRef.current = allItems;\n        setStateItems(allItems.slice(0, 20));\n    }, [allItems, element]);\n    react_1.useEffect(function () {\n        var currentElement = element;\n        var currentObserver = observer.current;\n        if (currentElement) {\n            currentObserver.observe(currentElement);\n        }\n        return function () {\n            if (currentElement) {\n                currentObserver.unobserve(currentElement);\n            }\n        };\n    }, [element]);\n    var nextItems = element ? stateItems : [];\n    return [nextItems, setRef];\n};\nexports.default = useInfiniteScroll;\n//# sourceMappingURL=useInfiniteScroll.js.map"]},"metadata":{},"sourceType":"script"}