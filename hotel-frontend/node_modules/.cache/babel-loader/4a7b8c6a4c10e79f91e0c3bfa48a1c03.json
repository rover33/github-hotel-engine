{"ast":null,"code":"import { useCallback, useState, useEffect, useRef } from 'react';\n\nfunction useWindowSize() {\n  var validWindow = typeof window === 'object';\n  var getSize = useCallback(function () {\n    var size = {\n      width: validWindow ? window.innerWidth : undefined,\n      height: validWindow ? window.innerHeight : undefined\n    };\n    return size;\n  }, [validWindow]);\n\n  var _useState = useState(getSize()),\n      size = _useState[0],\n      setSize = _useState[1];\n\n  useEffect(function () {\n    function handleResize() {\n      setSize(getSize());\n    }\n\n    if (validWindow) {\n      window.addEventListener('resize', handleResize);\n      return function () {\n        window.removeEventListener('resize', handleResize);\n      };\n    }\n  }, [getSize, validWindow]);\n  return size;\n}\n\nfunction useInterval(callback, delay) {\n  var savedCallback = useRef(null);\n  useEffect(function () {\n    savedCallback.current = callback;\n  }, [callback]);\n  useEffect(function () {\n    function tick() {\n      var _savedCallback$curren;\n\n      (_savedCallback$curren = savedCallback.current) === null || _savedCallback$curren === void 0 ? void 0 : _savedCallback$curren.call(savedCallback);\n    }\n\n    if (delay) {\n      var id = setInterval(function () {\n        tick();\n      }, delay);\n      return function () {\n        clearInterval(id);\n      };\n    }\n  }, [delay]);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nfunction isNullOrUndefined(value) {\n  return [null, undefined].includes(value);\n}\n\nvar WINDOW = 'window';\nvar PARENT = 'parent';\n\nfunction getElementSizes(element) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  var parentRect = element.getBoundingClientRect();\n  var top = parentRect.top,\n      bottom = parentRect.bottom,\n      left = parentRect.left,\n      right = parentRect.right;\n  return {\n    top: top,\n    bottom: bottom,\n    left: left,\n    right: right\n  };\n}\n\nfunction isElementInView(element, windowHeight, windowWidth) {\n  if (element) {\n    var _getElementSizes = getElementSizes(element),\n        left = _getElementSizes.left,\n        right = _getElementSizes.right,\n        top = _getElementSizes.top,\n        bottom = _getElementSizes.bottom;\n\n    if (left > windowWidth) {\n      return false;\n    } else if (right < 0) {\n      return false;\n    } else if (top > windowHeight) {\n      return false;\n    } else if (bottom < 0) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nfunction useInfiniteScroll(_ref) {\n  var loading = _ref.loading,\n      hasNextPage = _ref.hasNextPage,\n      onLoadMore = _ref.onLoadMore,\n      _ref$threshold = _ref.threshold,\n      threshold = _ref$threshold === void 0 ? 150 : _ref$threshold,\n      _ref$checkInterval = _ref.checkInterval,\n      checkInterval = _ref$checkInterval === void 0 ? 200 : _ref$checkInterval,\n      _ref$scrollContainer = _ref.scrollContainer,\n      scrollContainer = _ref$scrollContainer === void 0 ? WINDOW : _ref$scrollContainer;\n  var ref = useRef(null);\n\n  var _useWindowSize = useWindowSize(),\n      windowHeight = _useWindowSize.height,\n      windowWidth = _useWindowSize.width; // Normally we could use the \"loading\" prop, but when you set \"checkInterval\" to a very small\n  // number (like 10 etc.), some request components can't set its loading state\n  // immediately (I had this problem with react-apollo's Query component. In some cases, it runs\n  // \"updateQuery\" twice). Thus we set our own \"listen\" state which immeadiately turns to \"false\" on\n  // calling \"onLoadMore\".\n\n\n  var _useState = useState(true),\n      listen = _useState[0],\n      setListen = _useState[1];\n\n  useEffect(function () {\n    if (!loading) {\n      setListen(true);\n    }\n  }, [loading]);\n\n  function getBottomOffset() {\n    var element = ref.current;\n\n    if (!element || isNullOrUndefined(windowHeight)) {\n      return null;\n    }\n\n    var rect = element.getBoundingClientRect();\n    var bottom = rect.bottom;\n    var bottomOffset = bottom - windowHeight;\n\n    if (scrollContainer === PARENT) {\n      var parent = element.parentNode;\n\n      if (!parent) {\n        return null;\n      }\n\n      var _getElementSizes2 = getElementSizes(parent),\n          parentBottom = _getElementSizes2.bottom; // Distance between bottom of list and its parent\n\n\n      bottomOffset = bottom - parentBottom;\n    }\n\n    return bottomOffset;\n  }\n\n  function isParentInView() {\n    var _ref$current;\n\n    var parent = (_ref$current = ref.current) === null || _ref$current === void 0 ? void 0 : _ref$current.parentNode;\n\n    if (!parent || isNullOrUndefined(windowHeight) || isNullOrUndefined(windowWidth)) {\n      return false;\n    }\n\n    return isElementInView(parent, windowHeight, windowWidth);\n  }\n\n  function isListInView() {\n    var element = ref.current;\n\n    if (!element || isNullOrUndefined(windowHeight) || isNullOrUndefined(windowWidth)) {\n      return false;\n    }\n\n    return isElementInView(element, windowHeight, windowWidth);\n  }\n\n  function listenBottomOffset() {\n    if (listen && !loading && hasNextPage) {\n      if (ref.current) {\n        if (scrollContainer === PARENT) {\n          if (!isParentInView()) {\n            // Do nothing if the parent is out of screen\n            return;\n          }\n        } else if (!isListInView()) {\n          return;\n        } // Check if the distance between bottom of the container and bottom of the window or parent\n        // is less than \"threshold\"\n\n\n        var bottomOffset = getBottomOffset();\n\n        if (isNullOrUndefined(bottomOffset)) {\n          return;\n        }\n\n        var validOffset = bottomOffset < threshold;\n\n        if (validOffset) {\n          setListen(false);\n          onLoadMore();\n        }\n      }\n    }\n  }\n\n  useInterval(function () {\n    listenBottomOffset();\n  }, // Stop interval when there is no next page.\n  hasNextPage ? checkInterval : 0);\n  return ref;\n}\n\nexport default useInfiniteScroll;","map":{"version":3,"sources":["../src/useWindowSize.ts","../src/useInterval.ts","../src/utils.ts","../src/useInfiniteScroll.ts"],"names":["validWindow","getSize","useCallback","size","width","window","height","undefined","setSize","useState","useEffect","savedCallback","useRef","id","setInterval","tick","clearInterval","isNullOrUndefined","value","WINDOW","PARENT","parentRect","element","top","bottom","left","right","getElementSizes","loading","hasNextPage","onLoadMore","threshold","checkInterval","scrollContainer","ref","windowHeight","windowWidth","useWindowSize","listen","setListen","rect","bottomOffset","parent","parentBottom","isElementInView","isParentInView","isListInView","getBottomOffset","validOffset","useInterval","listenBottomOffset"],"mappings":"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","sourcesContent":["import { useState, useEffect, useCallback } from 'react';\r\n\r\nfunction useWindowSize() {\r\n  const validWindow = typeof window === 'object';\r\n\r\n  const getSize = useCallback(() => {\r\n    const size = {\r\n      width: validWindow ? window.innerWidth : undefined,\r\n      height: validWindow ? window.innerHeight : undefined,\r\n    };\r\n\r\n    return size;\r\n  }, [validWindow]);\r\n\r\n  const [size, setSize] = useState(getSize());\r\n\r\n  useEffect(() => {\r\n    function handleResize() {\r\n      setSize(getSize());\r\n    }\r\n\r\n    if (validWindow) {\r\n      window.addEventListener('resize', handleResize);\r\n\r\n      return () => {\r\n        window.removeEventListener('resize', handleResize);\r\n      };\r\n    }\r\n  }, [getSize, validWindow]);\r\n\r\n  return size;\r\n}\r\n\r\nexport default useWindowSize;\r\n","import { useRef, useEffect } from 'react';\r\nimport { Maybe } from './types';\r\n\r\nfunction useInterval(callback: VoidFunction, delay: number) {\r\n  const savedCallback = useRef<Maybe<VoidFunction>>(null);\r\n\r\n  useEffect(() => {\r\n    savedCallback.current = callback;\r\n  }, [callback]);\r\n\r\n  useEffect(() => {\r\n    function tick() {\r\n      savedCallback.current?.();\r\n    }\r\n\r\n    if (delay) {\r\n      const id = setInterval(() => {\r\n        tick();\r\n      }, delay);\r\n      return () => {\r\n        clearInterval(id);\r\n      };\r\n    }\r\n  }, [delay]);\r\n}\r\n\r\nexport default useInterval;\r\n","import { NullOrUndefined } from './types';\r\n\r\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\r\nexport function isNullOrUndefined(value: any): value is NullOrUndefined {\r\n  return [null, undefined].includes(value);\r\n}\r\n","import { useEffect, useRef, useState } from 'react';\r\nimport useWindowSize from './useWindowSize';\r\nimport useInterval from './useInterval';\r\nimport { isNullOrUndefined } from './utils';\r\nexport type InfiniteScrollContainer = 'window' | 'parent';\r\nconst WINDOW: InfiniteScrollContainer = 'window';\r\nconst PARENT: InfiniteScrollContainer = 'parent';\r\n\r\ntype InfiniteContainer = HTMLElement | (Node & ParentNode);\r\n\r\nfunction getElementSizes(element: InfiniteContainer) {\r\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n  const parentRect = (element as any).getBoundingClientRect();\r\n  const { top, bottom, left, right } = parentRect;\r\n  return { top, bottom, left, right };\r\n}\r\n\r\nfunction isElementInView(\r\n  element: InfiniteContainer,\r\n  windowHeight: number,\r\n  windowWidth: number,\r\n) {\r\n  if (element) {\r\n    const { left, right, top, bottom } = getElementSizes(element);\r\n    if (left > windowWidth) {\r\n      return false;\r\n    } else if (right < 0) {\r\n      return false;\r\n    } else if (top > windowHeight) {\r\n      return false;\r\n    } else if (bottom < 0) {\r\n      return false;\r\n    }\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\nexport interface UseInfiniteScrollArgs {\r\n  // Some sort of \"fetching\" info of the request.\r\n  loading: boolean;\r\n  // If the list has more items to load.\r\n  hasNextPage: boolean;\r\n  // The callback function to execute when the threshold is exceeded.\r\n  onLoadMore: Function;\r\n  // Maximum distance to bottom of the window/parent to trigger the callback. Default is 150.\r\n  threshold?: number;\r\n  // Frequency to check the dom. Default is 200.\r\n  checkInterval?: number;\r\n  // May be `\"window\"` or `\"parent\"`. Default is `\"window\"`. If you want to use a scrollable parent for the infinite list, use `\"parent\"`.\r\n  scrollContainer?: InfiniteScrollContainer;\r\n}\r\n\r\nfunction useInfiniteScroll<T extends HTMLElement>({\r\n  loading,\r\n  hasNextPage,\r\n  onLoadMore,\r\n  threshold = 150,\r\n  checkInterval = 200,\r\n  scrollContainer = WINDOW,\r\n}: UseInfiniteScrollArgs) {\r\n  const ref = useRef<T>(null);\r\n  const { height: windowHeight, width: windowWidth } = useWindowSize();\r\n  // Normally we could use the \"loading\" prop, but when you set \"checkInterval\" to a very small\r\n  // number (like 10 etc.), some request components can't set its loading state\r\n  // immediately (I had this problem with react-apollo's Query component. In some cases, it runs\r\n  // \"updateQuery\" twice). Thus we set our own \"listen\" state which immeadiately turns to \"false\" on\r\n  // calling \"onLoadMore\".\r\n  const [listen, setListen] = useState(true);\r\n\r\n  useEffect(() => {\r\n    if (!loading) {\r\n      setListen(true);\r\n    }\r\n  }, [loading]);\r\n\r\n  function getBottomOffset() {\r\n    const element = ref.current;\r\n\r\n    if (!element || isNullOrUndefined(windowHeight)) {\r\n      return null;\r\n    }\r\n\r\n    const rect = element.getBoundingClientRect();\r\n\r\n    const bottom = rect.bottom;\r\n    let bottomOffset = bottom - windowHeight;\r\n\r\n    if (scrollContainer === PARENT) {\r\n      const parent = element.parentNode;\r\n      if (!parent) {\r\n        return null;\r\n      }\r\n      const { bottom: parentBottom } = getElementSizes(parent);\r\n      // Distance between bottom of list and its parent\r\n      bottomOffset = bottom - parentBottom;\r\n    }\r\n\r\n    return bottomOffset;\r\n  }\r\n\r\n  function isParentInView() {\r\n    const parent = ref.current?.parentNode;\r\n    if (\r\n      !parent ||\r\n      isNullOrUndefined(windowHeight) ||\r\n      isNullOrUndefined(windowWidth)\r\n    ) {\r\n      return false;\r\n    }\r\n    return isElementInView(parent, windowHeight, windowWidth);\r\n  }\r\n\r\n  function isListInView() {\r\n    const element = ref.current;\r\n    if (\r\n      !element ||\r\n      isNullOrUndefined(windowHeight) ||\r\n      isNullOrUndefined(windowWidth)\r\n    ) {\r\n      return false;\r\n    }\r\n    return isElementInView(element, windowHeight, windowWidth);\r\n  }\r\n\r\n  function listenBottomOffset() {\r\n    if (listen && !loading && hasNextPage) {\r\n      if (ref.current) {\r\n        if (scrollContainer === PARENT) {\r\n          if (!isParentInView()) {\r\n            // Do nothing if the parent is out of screen\r\n            return;\r\n          }\r\n        } else if (!isListInView()) {\r\n          return;\r\n        }\r\n\r\n        // Check if the distance between bottom of the container and bottom of the window or parent\r\n        // is less than \"threshold\"\r\n        const bottomOffset = getBottomOffset();\r\n\r\n        if (isNullOrUndefined(bottomOffset)) {\r\n          return;\r\n        }\r\n\r\n        const validOffset = bottomOffset < threshold;\r\n\r\n        if (validOffset) {\r\n          setListen(false);\r\n          onLoadMore();\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  useInterval(\r\n    () => {\r\n      listenBottomOffset();\r\n    },\r\n    // Stop interval when there is no next page.\r\n    hasNextPage ? checkInterval : 0,\r\n  );\r\n\r\n  return ref;\r\n}\r\n\r\nexport default useInfiniteScroll;\r\n"]},"metadata":{},"sourceType":"module"}